# Inferencia causal

Responder a preguntas causales es crucial para fines científicos, pero técnicas como ensayos clínicos aleatorios no siempre son posibles de realizar. Las herramientas que aprenderás con este libro te permitirán realizar inferencias causales con mayor eficacia a partir de datos observacionales utilizando el lenguaje de programación R.

```{r echo =FALSE}
library(ggplot2)
library(showtext)

options(
  # set default colors in ggplot2 to colorblind-friendly
  # Okabe-Ito and Viridis palettes
  ggplot2.discrete.colour = ggokabeito::palette_okabe_ito(),
  ggplot2.discrete.fill = ggokabeito::palette_okabe_ito(),
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis",
  # set theme font and size
  book.base_family = "sans",
  book.base_size = 14
)

library(ggplot2)

# set default theme
theme_set(
  theme_minimal(
    base_size = getOption("book.base_size"),
    base_family = getOption("book.base_family")
  ) %+replace%
    theme(
      panel.grid.minor = element_blank(),
      legend.position = "bottom"
    )
)

theme_dag <- function() {
  ggdag::theme_dag(base_family = getOption("book.base_family"))
}

geom_dag_label_repel <- function(..., seed = 10) {
  ggdag::geom_dag_label_repel(
    aes(x, y, label = label),
    box.padding = 3.5,
    inherit.aes = FALSE,
    max.overlaps = Inf,
    family = getOption("book.base_family"),
    seed = seed,
    label.size = NA,
    label.padding = 0.1,
    size = getOption("book.base_size") / 3,
    ...
  )
}

```

# Modelos causales

## Criterios de hill

A menudo se hace referencia a los criterios de Hill como la definición estándar de causalidad en epidemiología (con casi 10 000 citas). Hill propone 9 criterios, utilizando el ejemplo de la evaluación de la causalidad entre la exposición al tabaquismo y el cáncer de pulmón.

1.  Asociación fuerte : ¿La exposición está asociada con un efecto importante en el empeoramiento del resultado?

2.  Consistencia : ¿Se han repetido los hallazgos del estudio en diferentes circunstancias?

3.  Especificidad : ¿Se puede vincular la exposición a una enfermedad o causa específica de mortalidad?

4.  Temporalidad : ¿Se mide la exposición antes de la incidencia del resultado?

5.  Gradiente biológico : ¿Existe una relación dosis-respuesta entre la exposición y la gravedad de la enfermedad?

6.  Plausibilidad : ¿Es biológicamente plausible una relación causal?

7.  Coherencia : ¿La relación causal hipotética es coherente con el conocimiento existente?

8.  Experimentación : ¿Se puede verificar la relación causal mediante experimentación?

9.  Analogía : ¿Podemos definir una analogía entre el efecto hipotético y otra relación causal aceptada?

Los criterios de Hill representan un conjunto de consideraciones pero no proporcionan una definición replicable de causalidad para diferentes escenarios. Esta cuestión da motivó a que otros marcos concepturales pretendan explicar mejor que es la causalidad.

## El marco de desenlaces potenciales - modelo de Rubin

Se basa en la idea de comparar los resultados observados con los resultados que habrían ocurrido si se hubieran tomado diferentes acciones o si las condiciones hubieran sido diferentes. Estos resultados alternativos, que no se observan directamente en los datos, se conocen como resultados contrafactuales.

El concepto de resultados contrafactuales es fundamental para entender el efecto causal de una intervención o tratamiento. Implica imaginar qué habría pasado con un individuo o grupo si hubieran sido expuestos a una condición diferente o a un tratamiento alternativo. Esta comparación entre lo que ocurrió y lo que podría haber ocurrido bajo diferentes circunstancias permite estimar el efecto causal de una intervención y entender su impacto en los resultados observados.

```{r, echo=FALSE}
knitr::include_graphics("fig/contrafactual.png")
```

Ver más abajo (será uno de nuestros enfoques principales)

## Gráficos acíclicos dirigidos (DAGs)

Modelo causal de Judea Perl - DAGs

Estos gráficos representan relaciones causales entre variables mediante flechas direccionales, donde una flecha apunta desde la variable que se considera la causa hacia la variable que se considera el efecto. La característica fundamental de un DAG es que no contiene ciclos, lo que significa que no hay una secuencia de flechas que forme un bucle cerrado. Esto refleja la ausencia de relaciones causales circulares o retroalimentación en el sistema representado (ya que esto incumpliria el supuesto de temporalidad).

Los DAG son útiles para representar y visualizar hipótesis causales y ayudan a los investigadores a identificar posibles relaciones causales entre variables y a entender la estructura causal subyacente en un conjunto de datos. Además, los DAG proporcionan un marco formal para especificar modelos causales y para derivar implicaciones de causalidad a partir de datos observacionales. Esto permite realizar inferencias causales sólidas y evaluar el impacto de intervenciones potenciales en sistemas complejos.

```{r, echo=FALSE}
knitr::include_graphics("fig/DAG.png")
```

## Marco de Rothman

El modelo de causa de componentes suficientes de Rothman, postula un conjunto de mecanismos causales diferentes, cada uno de los cuales es suficiente para provocar el resultado que se está considerando. Rothman se refiere a estos mecanismos causales hipotéticos como “causas suficientes”, concibiéndolos como conjuntos mínimos de acciones, eventos o estados de la naturaleza que juntos inician un proceso que da como resultado el desenlace.

Por lo tanto, se supone que cada causa suficiente consta de un conjunto de "causas componentes". Siempre que todos los componentes de una causa suficiente particular están presentes, se produce el desenlace; así, dentro de cada causa suficiente, cada componente sería necesario para que esa causa suficiente conduzca al desenlace.

En los modelos tradicionales de causa de componentes suficientes \[SCC\], el resultado y todas las causas componentes son eventos o, de manera equivalente, variables aleatorias binarias. Un modelo SCC con k causas componentes implica un conjunto de 2 k resultados potenciales. Por el contrario, en la sección 2 mostramos que para cualquier lista dada de resultados potenciales existe al menos un modelo SCC que representa este conjunto. Sin embargo, en general puede haber muchos modelos de SCC de este tipo.

```{r, echo=FALSE}
knitr::include_graphics("fig/rothman.jpg")
```

# ✅Modelo causal de Rubin - Resultados potenciales

El enfoque de Rubin, basado en el concepto de "potential outcomes" o resultados potenciales, se centra en estimar el efecto causal promedio de una intervención mediante la comparación de unidades tratadas y no tratadas. Por otro lado, el enfoque de Pearl, basado en la teoría de grafos causales, utiliza diagramas causales para representar y analizar las relaciones causales entre variables, permitiendo la identificación de caminos causales y la realización de inferencias causales más detalladas.

En la mayoría de cursos dan poca importancia a los resultados potenciales, en gran parte porque la idea de inferencia causal a través de DAGs (Modelo causal de Judea Perl) es más simple.

El enfoque de resultados potenciales es increíblemente popular y está muy extendido en las ciencias sociales (particularmente en economía), mientras que los modelos causales y los DAG son más populares en campos como la epidemiología. Por razones insondables, existe una extraña animosidad entre estos dos mundos. Judea Pearl critica regularmente a los científicos sociales en Twitter por no utilizar DAG y aferrarse a resultados potenciales, mientras que los econometristas ganadores del Nobel condenan los DAG. Es raro y gracioso.

Esta visión de la causalidad sostiene que para cualquier tipo de intervención (aprobar una nueva política, participar en un programa sin fines de lucro, tomar un tipo específico de medicamento, etc.), las personas tendrán uno de dos resultados posibles:

1.  ¿Qué pasaría si reciben la intervención o tratamiento?, y

2.  ¿Qué pasaría si no reciben el tratamiento?

Estos dos resultados son resultados potenciales. Ambos son plausibles, pero sólo uno sucederá en la vida real y el otro resultado sucederá en un mundo contrafactual (mundo que solo podrás acceder con una maquina del tiempo o viajando en el multiverso de la locura). Estos resultados potenciales conducen a un conjunto de estimaciones causales diferentes que podrían interesarnos, como el efecto promedio del tratamiento.

Más allá de introducir la idea de que no podemos encontrar efectos causales a nivel individual sin una máquina del tiempo, pensar en resultados potenciales es interesante y podría resultar muy útil para estimar efectos causales.

```{r echo=FALSE}
library(tidyverse)
library(ggtext)
library(ggdag)
library(dagitty)
library(gt)
library(broom)
library(marginaleffects)
library(WeightIt)

# Define a nice color palette from {MoMAColors}
# https://github.com/BlakeRMills/MoMAColors
clrs <- MoMAColors::moma.colors("ustwo")

# Download Mulish from https://fonts.google.com/specimen/Mulish

theme_nice <- function() {
  theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      plot.background = element_rect(fill = "white", color = NA),
      plot.title = element_text(face = "bold"),
      axis.title = element_text(face = "bold"),
      strip.text = element_text(face = "bold"),
      strip.background = element_rect(fill = "grey80", color = NA),
      legend.title = element_text(face = "bold")
    )
}

theme_set(theme_nice())

update_geom_defaults("text", list(fontface = "plain"))
update_geom_defaults("label", list(fontface = "plain"))
update_geom_defaults(ggdag:::GeomDagText, list( fontface = "plain"))
update_geom_defaults(ggtext::GeomRichText, list(fontface = "plain"))
```

Antes de entrar en las sutiles diferencias entre los distintos tipos de estimaciones relacionados con los resultados potenciales, es útil tener una idea general de cómo funcionan estas cosas. Así que vamos a introducrinos de forma progresiva sobre el marco de los resultados potenciales.

Todos los libros sobre inferencia causal incluyen una tabla como $Tabla 1$ para ilustrar los resultados potenciales. Para hacer esta idea un poco más matemática, llamaremos al tratamiento o intervención $X$, al resultado que ocurriría si se tratara $Y^1$, y al resultado que ocurriría si no se tratara $Y^0$. Utilizaremos $\delta$ para la diferencia entre $Y^1$ y $Y^0$, o el efecto causal a nivel individual.

```{r echo =FALSE}
#| label: tbl-basic-po
#| tbl-cap: "Standard table showing potential outcomes, individual causal effects, and realized outcomes"
#| code-fold: true
#| classes: no-stripe

basic_po <- tribble(
  ~id, ~age,    ~treated, ~outcome_1, ~outcome_0,
  1,   "Old",   1,        80,         60,
  2,   "Old",   1,        75,         70,
  3,   "Old",   1,        85,         80,
  4,   "Old",   0,        70,         60,
  5,   "Young", 1,        75,         70,
  6,   "Young", 0,        80,         80,
  7,   "Young", 0,        90,         100,
  8,   "Young", 0,        85,         80
) |> 
  mutate(
    ite = outcome_1 - outcome_0,
    outcome = ifelse(treated == 1, outcome_1, outcome_0)
  )

basic_po |> 
  select(
    id, age, treated, outcome_1, outcome_0, ite, outcome
  ) |> 
  gt() |> 
  sub_missing(missing_text = "…") |>
  fmt_number(
    columns = c(starts_with("outcome"), ite),
    decimals = 0
  ) |> 

  # Column labels
  cols_label(
    id = "ID",
    age = md("$Z_i$"),
    treated = md("$X_i$"),
    outcome_0 = md("$Y^0_i$"),
    outcome_1 = md("$Y^1_i$"),
    outcome = md("$Y_i$"),
    ite = md("$Y^1_i - Y^0_i$")
  ) |>
  
  # Level 1 spanner labels
  tab_spanner(
    label = "Age", columns = age, 
    level = 1, id = "level1_a_po"
  ) |> 
  tab_spanner(
    label = "Treated", columns = treated, 
    level = 1, id = "level1_b_po"
  ) |> 
  tab_spanner(
    label = "Potential outcomes",
    columns = c(outcome_1, outcome_0),
    level = 1, id = "level1_c_po"
  ) |> 
  tab_spanner(
    label = "ITE or \\(\\delta_i\\)", columns = ite, 
    level = 1, id = "level1_d_po"
  ) |> 
  tab_spanner(
    label = "Outcome", columns = outcome, 
    level = 1, id = "level1_e_po"
  ) |> 
  
  # Level 2 spanner labels
  tab_spanner(
    label = "Confounder",
    columns = age,
    level = 2, id = "level2_a_po"
  ) |> 
  tab_spanner(
    label = "Treatment", columns = treated, 
    level = 2, id = "level2_b_po"
  ) |> 
  tab_spanner(
    label = "Unobservable",
    columns = c(outcome_1, outcome_0, ite), 
    level = 2, id = "level2_c_po"
  ) |> 
  tab_spanner(
    label = "Realized", columns = outcome, 
    level = 2, id = "level2_d_po") |> 
  
  # Style stuff
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) |> 
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_body()
  ) |> 
  tab_style(
    style = cell_text(weight = "bold"),
    locations = list(
      cells_column_spanners(spanners = starts_with("level1")),
      cells_column_labels(columns = "id")
    )
  ) |> 
  tab_style(
    style = cell_text(style = "italic"),
    locations = cells_column_spanners(spanners = starts_with("level2"))
  ) |> 
  
  tab_style(
    style = list(
      cell_fill(color = clrs[4], alpha = 0.5)
    ),
    locations = cells_body(rows = treated == 1)
  ) |> 
  tab_footnote(
    footnote = "ite = individual causal effect",
    locations = cells_column_spanners(spanners = "level1_d_po")
  ) |> 
  opt_footnote_marks(marks = "standard") |> 
  opt_horizontal_padding(scale = 3) |> 
  opt_table_font(font = "Jost")
```

## Efectos causales a nivel individual (ITE o $\delta$)

Cada persona de $Tabla 1$ tiene dos resultados potenciales. La persona 1, por ejemplo, tendría un resultado de 80 ($Y^1$) si recibe el tratamiento $X$, pero sólo un resultado de 60 ($Y^0$) si no lo recibe. Su *efecto causal a nivel individual* ($\delta$) es de 20. Esto representa el efecto del tratamiento para el paciente. Esto representa el efecto del tratamiento sólo para esa persona, y sólo se puede medir con una máquina del tiempo o alguna forma de observar universos paralelos.

## Efectos medios del tratamiento (ATE)

Si pudiéramos comparar a todas estas personas en el Universo A y el Universo B y medir sus efectos causales individuales, podríamos calcular el *efecto medio del tratamiento* (ATE), o el efecto de la intervención en toda la población. Oficialmente, el ATE es la media de la columna $\delta$, o la media de $Y^1 - Y^0$:

$$
\begin{aligned}
\text{ATE} &= E[\delta_i] & \text{ or} \\
\text{ATE} &= E[Y^1_i - Y^0_i]
\end{aligned}
$$

Dados los datos de la $Tabla 1$, el ATE es 5, es decir, la media de la columna $\delta$:

$$
\text{ATE} = \frac{20 + 5 + 5 + 5 + 10 + 0 + -10 + 5}{8} = 5
$$

## Efecto medio del tratamiento sobre los tratados (ATT)

Hay un par de efectos causales más que podemos medir. Podríamos querer saber la magnitud del efecto sólo para los que recibieron el tratamiento. Esto se denomina *efecto medio del tratamiento sobre los tratados* (ATT), y es la media de los efectos causales individuales sólo entre los que recibieron el tratamiento. Matematicamente, se define así:

$$
\begin{aligned}
\text{ATT} &= E[\delta_i \mid X_i = 1] & \text{or} \\
\text{ATT} &= E[Y^1_i - Y^0_i \mid X_i = 1]
\end{aligned}
$$

En este caso, eso significa que sólo estamos viendo el promedio $\delta$ para las filas 1, 2, 3 y 5 en $Tabla 1$:

$$
\text{ATT} = \frac{20 + 5 + 5 + 5}{4} = 8.75
$$

## Efecto medio del tratamiento sobre los no tratados (ATU)

También podemos calcular el *efecto medio del tratamiento sobre los no tratados* (ATU; a veces denominado ATC (por efecto sobre el grupo de control)) hallando la media de los efectos causales individuales entre los no tratados:

$$
\begin{aligned}
\text{ATU} &= E[\delta_i \mid X_i = 0] & \text{or} \\
\text{ATU} &= E[Y^1_i - Y^0_i \mid X_i = 0]
\end{aligned}
$$

Aquí, sólo estamos mirando el promedio $\delta$ para las filas 4, 6, 7 y 8 en $Tabla 1$:

$$
\text{ATU} = \frac{10 + 0 - 10 + 5}{4} = 1.25
$$

## Sesgo de selección

Existe una clara relación entre la ATE, la ATT y la ATU: la ATE es técnicamente una media ponderada de la ATT sumada a la media ponderada de la ATU (aquí $\pi$ significa "proporción", no 3,1415):

$$
\text{ATE} = (\pi_\text{Treated} \times \text{ATT}) + (\pi_\text{Untreated} \times \text{ATU})
$$

Aplicando esto a $Tabla 1$, podemos obtener el mismo ATE:

$$
\begin{aligned}
\text{ATE} &= (\frac{4}{8} \times 8.75) + (\frac{4}{8} \times 1.25) \\
&= 4.375 + 0.625 \\
&= 5
\end{aligned}
$$

Una de las razones por las que es útil descomponer el ATE en estas dos partes es que muestra que hay alguna diferencia sistemática entre las personas tratadas y las no tratadas. Esta diferencia se denomina "sesgo de selección". Las personas que eligieron ser tratadas lo hicieron por razones que sólo ellas conocen.

::: callout-note
## **NOTA**

No sólo necesitamos una máquina del tiempo para una buena inferencia causal, también necesitamos una máquina que pueda leer la mente de las personas para saber bajo que circunstancias optaran por la otra versión del tratamiento.
:::

Podemos ver el sesgo de selección en una descomposición alternativa de la ATE:

$$
\text{ATE} = \text{ATT} + \text{Selection bias}
$$

El hecho de que la ATT (8,75) sea mayor que la ATE (5) es una señal de que los dos grupos son diferentes. Esta intervención, sea cual sea, tiene un gran efecto en las personas tratadas que se apuntaron a ella, probablemente porque de algún modo sabían que la intervención les sería útil. Los que no recibieron tratamiento tienen una ATU realmente baja (1,25): probablemente no se apuntaron a la intervención porque sabían que no les ayudaría mucho.

## 📌Supuestos causales

Como la mayoría de los enfoques estadísticos, la validez de un análisis causal depende de qué tan bien se cumplan ciertos supuestos.

En el mundo real y en un momento dado, sólo uno de estos resultados potenciales es observable: es decir, el resultado vinculado a la exposición real que sufrió el individuo. Bajo ciertos supuestos, podemos aprovechar los datos de individuos expuestos a diferentes insumos para comparar las diferencias promedio en los resultados observados.

-   **Consistencia**: se debe tener en cuenta que la intervención / exposición a evaluar para responder su pregunta causal debe ser igual para todos los individuos. Matemáticamente, esto significa que, la exposición que se observa en un individuo al azar es exactamente igual a la exposición que recibieron los demás. Este supuesto puede descomponerse en:
    -   *Exposición bien definida*: asumimos que para cada valor de exposición, no hay diferencia entre los sujetos en la forma de medición y de clasificación de esa exposición. Dicho de otra manera, no existen múltiples versiones del tratamiento.
    -   *Ausencia de interferencia entre las unidades*: asumimos que el resultado (técnicamente todos los resultados potenciales , independientemente de si se observan) para cualquier sujeto no depende de la exposición de otro sujeto.
    -   **NOTA:** El supuesto 1 a veces se denomina supuesto de valor de tratamiento unitario estable o SUTVA (stable-unit-treatment-value-assumption, Imbens y Rubin 2015) . Del mismo modo, estos supuestos a veces se denominan condiciones de identificabilidad, ya que necesitamos que se cumplan para identificar estimaciones causales.
-   **Intercambiabilidad**: se debe asumir que los sujetos expuestos y no expuestos tienen la misma probabilidad de experimentar cualquier resultado antes de la exposición; es decir, los sujetos expuestos y no expuestos son intercambiables (por ende el ATT debería ser igual al ATU e igual al ATE). A veces se hace referencia a esta suposición como que no existe ningún factor de confusión no medido.
    -   Visto de una forma práctica: tanto los que reciben la intervención como aquellos que no la recibieron, deben tener la misma probabilidad (x% en ambos) de desarrollar el desenlace.
    -   No puedes comparar un grupo donde la probabilidad de desarrollar un evento sea del 60% vs otro grupo que solo tiene la probabilidad del 10%, sería injusto, ¿no?
-   **Positividad**: Asumimos que dentro de cada nivel y combinación de las variables de estudio (cada individuo dentro de cada subgrupo posible) tiene alguna posibilidad de experimentar todos los niveles de la exposición. A veces esto se denomina supuesto probabilístico .
    -   Visto de una forma práctica: tanto los que recibieron la intervención como aquellos que no la recibieron, tuvieron una probabilidad \>0% (un valor positivo) de ser asignados a los brazos evaluados.

**NOTA:** En la práctica, la mayoría de las suposiciones que necesitamos hacer para la inferencia causal son para que podamos hacer una comparación de manzanas con manzanas, ya que, queremos asegurarnos de que estamos comparando individuos que son similares, que servirían como buenos sustitutos de los contrafactuales de cada uno.

## Causalidad en ensayos clínicos

*¿Por qué es útil la aleatorización?*

Si observamos nuestros supuestos, los ensayos aleatorios resuelven en parte el supuesto de consistencia (la parte de exposición bien definida de forma predeterminada): ya que es dicha exposición lo que se aleatoriza. Lo mismo ocurre con la positividad; Si hemos asignado personas al azar a los grupos expuestos o no expuestos, conocemos la probabilidad de asignación (y sabemos que no es exactamente 0 o 1, en la mayoria de casos esa probabilidad se acerca al 50%).

Sin embargo, la aleatorización por sí sola no resuelve la parte de "no interferencia" del supuesto de consistencia, por ejemplo, si aleatorizamos a algunas personas para que reciban una vacuna contra una enfermedad transmisible, recibirla podría reducir la posibilidad de que quienes los rodean contraigan la enfermedad infecciosa porque cambia la probabilidad de exposición (efecto rebaño); otro ejemplo puede ser revisado con casos de efecto de derrame ("spillover bias").

Los ensayos aleatorios ideales resuelven la cuestión de la intercambiabilidad porque las poblaciones expuestas y no expuestas (en el límite) son inherentemente las mismas, ya que su estado de exposición se determinó mediante un proceso aleatorio (no por ningún factor que pudiera hacerlas diferentes entre sí).

*¡Cuidado!* En realidad, a menudo vemos que esta suposición es violada por cuestiones como el abandono o la falta de adherencia en los ensayos aleatorios. Si hay un abandono diferencial entre los grupos de exposición (por ejemplo, si los participantes asignados aleatoriamente al tratamiento tienen más probabilidades de abandonar un estudio y, por lo tanto, no observamos su resultado), entonces los grupos de exposición observados ya no son intercambiables. . Por lo tanto, nos enfrentaremos por una para el ensayo aleatorio ideal (donde se supone que la adherencia es perfecta y ningún participante abandona) y otra para los ensayos aleatorios realistas donde esto puede no ser así.

**¿Solo la aleatorización garantiza que se cumpla estos supuestos?**

Se tiene que tener en cuenta que se requiere más que la aleatorización para garantizar los supuestos:

-   Criterio de elegibilidad estrictos (si un participante no cumple todos los criterios no es elegible)

-   Definición exacta de la exposición (los investigadores controlan todas las condiciones)

-   Procedimientos de asignación (idealmente mediante un metodo aleatorio y garantizando el ocultamiento de la secuencia aleatoria y posterior cegamiento de la intervención)

-   Período de seguimiento (donde podría permitirse perdidas aleatorias en el seguimiento y en un porcentaje minimo)

-   Definición de resultados (garantizar que la forma de medición se igual para todos)

-   Plan de análisis

Veamos como estos elementos garantizan los supuestos. Por ejemplo, la intercambiabilidad puede abordarse mediante los criterios de elegibilidad (podemos restringir nuestro estudio solo a participantes para quienes la asignación de exposición es intercambiable), el procedimiento de asignación (podríamos usar una asignación de exposición aleatoria para garantizar la intercambiabilidad), el período de seguimiento (podemos asegurarnos de elegir un momento de inicio apropiado para nuestro período de seguimiento para asegurarnos de que no induzcamos sesgos; pensaremos más en esto en un capítulo futuro) y/o el plan de análisis (podemos ajustar cualquier factor que pueda causar que los grupos no sean intercambiables \[factores confusores\]).

```{r echo =FALSE}
library(gt)

# Crear la tabla con los datos
tabla_suposiciones <- tribble(
  ~Suposición, ~Criterio_de_elegibilidad, ~Definición_de_exposición, ~Procedimientos_de_asignación, ~Período_de_seguimiento, ~Definición_de_resultados, ~Contraste_causal, ~Plan_de_análisis,
    "Consistencia (exposición bien definida)", "✔️", "✔️", "", "", "", "", "",
  "Consistencia (sin interferencias)", "", "✔️", "✔️", "", "✔️", "", "✔️",
  "Positividad", "✔️", "", "✔️", "", "", "✔️", "",
  "Intercambiabilidad", "✔️", "", "✔️", "✔️", "" , "", "✔️",
)

# Formatear la tabla con gt
tabla_suposiciones %>%
  gt() %>%
  tab_style(
    style = cell_text(weight = "bold", align = "center"),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_body()
  ) %>%
  tab_options(
    table.width = pct(100),
    table.font.size = "medium"
  ) %>%
  opt_horizontal_padding(scale = 2)

```

# Más allá de la aleatorización

Hay muchas razones por las que la aleatorización puede no ser posible. Por ejemplo, puede que no sea ético asignar personas al azar a una exposición particular, puede que no haya fondos disponibles para realizar un ensayo aleatorio o puede que no haya tiempo suficiente para realizar un ensayo completo. En estas situaciones, confiamos en datos del mundo real (datos observacionales) que nos ayudarán a responder preguntas causales mediante la emulación de un ensayo clínico objetivo.

Un ensayo objetivo responde: ¿Qué experimento diseñarías si fuera posible? Especificar un ensayo objetivo es casi idéntico al proceso que describimos para un ensayo aleatorio. Definimos la elegibilidad, la exposición, el período de seguimiento, el resultado, la estimación de interés y el plan de análisis. La diferencia clave con el ensayo objetivo en el entorno observacional, por supuesto, es que no podemos asignar la intervención. El paso de planificación del análisis y ejecución de la prueba objetivo es el más complicado desde el punto de vista técnico y un enfoque central de este programa; por ejemplo, usar DAG para garantizar que hemos medido y estamos controlando el conjunto correcto de factores de confusión, componer programas estadísticos que invoquen un método de ajuste apropiado, como la ponderación de IPW, y realizar análisis de sensibilidad para evaluar qué tan sensibles son nuestras conclusiones a errores de especificación o confusión no medidos.

## Hallar el ATE a partir de datos observacionales

Todo esto está muy bien, pero no tenemos máquinas del tiempo para observar los dos resultados potenciales y la verdad es que solo podremos saber uno de los resultados. A esto se le denomina el *problema fundamental de la inferencia causal* (no tenemos ni idea de cuál es el $\delta$ de cada persona).

De hecho, sólo vemos esto en la vida real:

```{r echo =FALSE}
#| label: tbl-basic-realized
#| tbl-cap: "Observed version of @tbl-basic-po showing only the realized outcome"
#| code-fold: true
#| classes: no-stripe

basic_po |> 
  select(
    id, age, treated, outcome
  ) |> 
  gt() |> 
  fmt_number(
    columns = "outcome",
    decimals = 0
  ) |> 

  # Column labels
  cols_label(
    id = "ID",
    age = md("$Z_i$"),
    treated = md("$X_i$"),
    outcome = md("$Y_i$")
  ) |>
  
  # Level 1 spanner labels
  tab_spanner(
    label = "Age", columns = age, 
    level = 1, id = "level1_a_po_obs"
  ) |> 
  tab_spanner(
    label = "Treated", columns = treated, 
    level = 1, id = "level1_b_po_obs"
  ) |> 
  tab_spanner(
    label = "Outcome", columns = outcome, 
    level = 1, id = "level1_c_po_obs"
  ) |> 
  
  # Level 2 spanner labels
  tab_spanner(
    label = "Confounder",
    columns = age,
    level = 2, id = "level2_a_po_obs"
  ) |> 
  tab_spanner(
    label = "Treatment", columns = treated, 
    level = 2, id = "level2_b_po_obs"
  ) |> 
  tab_spanner(
    label = "Realized", columns = outcome, 
    level = 2, id = "level2_c_po_obs") |> 
  
  # Style stuff
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) |> 
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_body()
  ) |> 
  tab_style(
    style = cell_text(weight = "bold"),
    locations = list(
      cells_column_spanners(spanners = starts_with("level1")),
      cells_column_labels(columns = "id")
    )
  ) |> 
  tab_style(
    style = cell_text(style = "italic"),
    locations = cells_column_spanners(spanners = starts_with("level2"))
  ) |> 

  tab_style(
    style = list(
      cell_fill(color = clrs[4], alpha = 0.5)
    ),
    locations = cells_body(rows = treated == 1)
  ) |> 
  opt_horizontal_padding(scale = 3) |> 
  opt_table_font(font = "Jost")
```

Podríamos intentar hallar el ATE calculando el resultado medio entre los tratados ($\bar{Y}_\text{Tratados}$) y restándolo del resultado medio entre los no tratados ($\bar{Y}_\text{No tratados}$):

$$
\begin{aligned}
\text{ATE}_\text{naive} &= \bar{Y}_\text{Treated} - \bar{Y}_\text{Untreated} \\
&= \frac{80 + 75 + 85 + 75}{4} - \frac{60 + 80 + 100 + 80}{4} \\
&= 78.75 - 80 \\
&= -1.25
\end{aligned}
$$

Pero esto es terriblemente erróneo. El sesgo de selección está distorsionando el efecto causal. Las personas tratadas buscaron el tratamiento porque sabían que sería bueno para ellas. No podemos comparar los dos grupos directamente de esta manera debido a las diferencias sistemáticas entre ellos.

Tenemos que tener en cuenta de alguna manera el hecho de que los dos grupos son diferentes. Durante todo este tiempo hemos ignorado una columna de la tabla: la edad ($Z$). Parece que la edad está muy correlacionada con el estado del tratamiento. El 75% de las personas que se apuntaron al tratamiento eran mayores; el 75% de las personas que no se apuntaron al tratamiento eran jóvenes. En términos de DAG, la edad parece ser un factor de confusión: causa tanto la elección de recibir tratamiento como el valor final del resultado. La edad abre una puerta trasera en la relación entre el tratamiento y el resultado y desordena el efecto causal. Si de algún modo podemos tener en cuenta estadísticamente la edad, obtendremos una estimación más precisa de la ATE real.

**NOTA: ¿Quizás este tratamiento es una colonoscopia? usa tu imaginación.**

```{r echo =FALSE}
#| label: fig-dag-basic
#| fig-cap: "DAG showing that age confounds the relationship between treatment and outcome"
#| code-fold: true
#| fig-width: 4.5
#| fig-height: 2.5
#| out-width: "70%"

basic_dag <- dagify(
  Y ~ X + Z,
  X ~ Z,
  exposure = "X",
  outcome = "Y",
  coords = list(
    x = c(X = 1, Y = 3, Z = 2),
    y = c(X = 1, Y = 1, Z = 2)
  )
)

basic_dag_plot <- basic_dag |> 
  tidy_dagitty() |> 
  mutate(var_type = case_when(
    name == "X" ~ "Exposure",
    name == "Y" ~ "Outcome",
    str_detect(name, "Z") ~ "Confounder"
  )) |> 
  mutate(var_label = case_match(name,
    "X" ~ "Treatment",
    "Y" ~ "Outcome",
    "Z" ~ "Age"
  ))

ggplot(basic_dag_plot, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges() +
  geom_dag_point(aes(color = var_type), size = 12) +
  geom_richtext(
    aes(label = name), fontface = "bold", color = "white",
    fill = NA, label.color = NA,
    label.padding = grid::unit(c(3, 0, 0, 0), "pt")
  ) + 
  geom_dag_text(
    data = filter(basic_dag_plot, var_type != "Confounder"), aes(label = var_label), 
    nudge_y = -0.25, color = "black", size = 11, size.unit = "pt"
  ) +
  geom_dag_text(
    data = filter(basic_dag_plot, var_type == "Confounder"), aes(label = var_label), 
    nudge_y = 0.26, color = "black", size = 11, size.unit = "pt"
  ) +
  scale_color_manual(values = clrs[c(4, 1, 6)], guide = "none") +
  theme_dag()
```

Existen muchas formas de ajustar la edad (hay libros de texto enteros sobre este tema: emparejamiento, ponderación de probabilidad inversa, etc.). Una forma sencilla es estratificar por edad y hallar la suma de las medias ponderadas de los mayores y los jóvenes, de la siguiente manera:

$$
\text{ATE} = (\pi_\text{Old} \times \text{Effect}_\text{Old}) + (\pi_\text{Young} \times \text{Effect}_\text{Young})
$$

Con los datos de la tabla, obtenemos:

$$
\begin{aligned}
\text{Effect}_\text{Stratified} &= (\pi_\text{Treated} \times \bar{Y}_\text{Treated}) - (\pi_\text{Untreated} \times \bar{Y}_\text{Untreated}) \\[20pt]
\text{Effect}_\text{Old} &= \frac{80 + 75 + 85}{3} - \frac{60}{1} &&= 20 \\
\text{Effect}_\text{Young} &= \frac{75}{1} - \frac{80 + 100 + 80}{3} &&= -11.667 \\[20pt]
\text{ATE} &= (\frac{4}{8} \times 20) + (\frac{4}{8} \times -11.667) &&= 4.1667
\end{aligned}
$$

4,1667 no es exactamente el verdadero ATE (cuando teniamos toda la info vimos que el verdaedro valor de ATE era 5), ¡pero está sorprendentemente cerca! Si tuviéramos más de 8 filas de datos, nos acercaríamos aún más (siempre que la edad fuera realmente el único factor de confusión).

Recorrer una tabla como ésta es un ejercicio útil. Ilustra cómo los efectos causales individuales son inobservables. Muestra cómo podríamos encontrar teóricamente el efecto medio del tratamiento de alguna intervención. Destaca el papel que desempeñan el sesgo de selección y la confusión en la distorsión de los efectos causales. Señala formas de tener en cuenta la confusión mediante ajustes estadísticos.

Exploremos los matices de los distintos tipos de efectos del tratamiento utilizando un conjunto de datos de resultados potenciales más realista, basado en una hipotética intervención de desarrollo internacional diseñada para reducir el riesgo de paludismo mediante el uso de mosquiteros. Los datos son observacionales y no experimentales: las personas deciden utilizar o no las mosquiteros en función de sus preferencias personales. En este caso, los ingresos y la salud confunden la relación mosquitero → riesgo de paludismo: los ingresos influyen en la salud, y tanto los ingresos como la salud influyen en la decisión de utilizar una mosquitero y en el riesgo general de paludismo.

```{r echo = FALSE}
#| label: fig-dag-mosquito
#| fig-cap: "DAG showing the relationship between mosquito net use and malaria risk, confounded by health and income"
#| code-fold: true
#| fig-width: 6
#| fig-height: 3.5

mosquito_dag <- dagitty('
dag {
"X" [exposure,pos="1,1"]
"Y" [outcome,pos="4,1"]
"Z<sub>1</sub>" [pos="2,2"]
"Z<sub>2</sub>" [pos="3,2"]
"Z<sub>2</sub>" -> "Y"
"Z<sub>2</sub>" -> "X"
"Z<sub>1</sub>" -> "Y"
"Z<sub>1</sub>" -> "Z<sub>2</sub>"
"Z<sub>1</sub>" -> "X"
"X" -> "Y"
}')

dag_plot <- mosquito_dag |> 
  tidy_dagitty() |> 
  mutate(var_type = case_when(
    name == "X" ~ "Exposure",
    name == "Y" ~ "Outcome",
    str_detect(name, "Z") ~ "Confounder"
  )) |> 
  mutate(var_label = case_match(name,
    "X" ~ "Mosquito net",
    "Y" ~ "Malaria risk",
    "Z<sub>1</sub>" ~ "Income",
    "Z<sub>2</sub>" ~ "Health"
  ))

ggplot(dag_plot, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges() +
  geom_dag_point(aes(color = var_type), size = 12) +
  geom_richtext(
    aes(label = name), fontface = "bold", color = "white",
    fill = NA, label.color = NA,
    label.padding = grid::unit(c(3, 0, 0, 0), "pt")
  ) + 
  geom_dag_text(
    data = filter(dag_plot, var_type != "Confounder"), aes(label = var_label), 
    nudge_y = -0.15, color = "black", size = 11, size.unit = "pt"
  ) +
  geom_dag_text(
    data = filter(dag_plot, var_type == "Confounder"), aes(label = var_label), 
    nudge_y = 0.16, color = "black", size = 11, size.unit = "pt"
  ) +
  scale_color_manual(values = clrs[c(4, 1, 6)], guide = "none") +
  theme_dag()
```

**En este conjunto de datos, la verdadera ATE es -15.** El uso de un mosquitero provoca una disminución media de 15 unidades en el riesgo de paludismo en toda la población.

Veamos la base de datos a utilizar

```{r echo =FALSE}
#| label: generate-data
#| code-fold: true
#| code-summary: "Code for generating synthetic mosquito net data"

withr::with_seed(1234, {
  n <- 1500
  
  nets <- tibble(
    # Generate exogenous variables
    id = 1:n,
    income = rnorm(n, 500, 100)
  ) |> 
    # Generate health, which depends on income
    mutate(
      health = (0.1 * income) + rnorm(n, 0, 10),
      health = pmin(pmax(health, 0), 100)  # Force values to 0-100 range
    ) |> 
    # Generate net usage (treatment), which depends on health and income
    mutate(
      # Make people with high health and high income a lot more likely to
      # self-select into treatment
      income_high = income > quantile(income, 0.8),
      health_high = health > quantile(health, 0.8),
      
      # Create latent propensity scores based on logit formula
      net_prob = plogis(
        -3 + (income / 300) + (health / 40) + 
          (0.9 * income_high) + (0.5 * health_high)),
      
      # Assign to treatment
      net = rbinom(n, 1, 
        # Fancy little trick---increase the latent propensity score by 5
        # percentage points for people already more likely (i.e. p > 50%) to
        # receive treatment and decrease the propensity score by 8 percentage
        # points for those already less likely to receive treatment
        prob = ifelse(
          net_prob > 0.5, 
          pmin(net_prob + 0.05, 0.98), 
          pmax(net_prob - 0.08, 0.02))
        )
    ) |> 
    # Generate potential and actual outcomes
    mutate(
      # Individual outcomes in a world where individuals are not treated
      malaria_risk_0 = 90 + (-0.2 * health) + (-0.05 * income) + rnorm(n, 0, 6),
      malaria_risk_0 = pmin(pmax(malaria_risk_0, 0), 100),  # Force values to 0-100
      
      # Individual outcomes in a world where individuals are treated
      # Basically risk_0 + a baseline treatment effect + extra treatment effect
      # boosts because of income and health
      malaria_risk_1 = malaria_risk_0 - 
        rnorm(n, 3, 1) - (0.015 * income) - (0.09 * health),
      malaria_risk_1 = pmin(pmax(malaria_risk_1, 0), 100),  # Force values to 0-100
      
      # Round stuff
      malaria_risk_0 = round(malaria_risk_0, 1),
      malaria_risk_1 = round(malaria_risk_1, 1),
      
      ite = malaria_risk_1 - malaria_risk_0,
      
      # Actual realized outcome
      malaria_risk = ifelse(net == 1, malaria_risk_1, malaria_risk_0)
    ) |> 
    # Round more stuff
    mutate(across(c(income, health), ~round(., 0))) |> 
    # Only keep some columns
    select(
      id, income, income_high, health, health_high, net,
      starts_with("malaria"), ite
    )
})

write_csv(nets, "mosquito_nets_v2.csv")

#nets

DT::datatable(nets,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )

```

Tenemos cuatro variables principales en estos datos:

-   **Uso del mosquitero** *(Tratamiento)*: Variable binaria 0/1, VERDADERO/FALSO, que indica si la persona utiliza un mosquitero.

-   **Riesgo de paludismo** *(Resultado)*: Escala de 0-100, donde los valores más altos representan un mayor riesgo.

-   **Ingresos** *(factor de confusión)*: Ingresos semanales, medidos en dólares. A mayores ingresos, mayor probabilidad de utilizar mosquitero; las personas por encima del percentil 80 obtienen un aumento adicional de la probabilidad.

-   **Salud** *(factor de confusión)*: Estado de salud, escala de 0 a 100; los valores más altos representan un mejor estado de salud. Un mejor estado de salud provoca una mayor probabilidad de utilizar un mosquitero; las personas por encima del percentil 80 obtienen un aumento adicional de la probabilidad.

```{r echo =FALSE}
#| label: tabla_2
#| tbl-cap: "Potential outcomes, individual causal effects, and realized outcomes for synthetic mosquito net data"
#| code-fold: true
#| classes: no-stripe

excerpt <- nets |> 
  slice(c(3, 14, 15, 29, 4, 35, 37, 73)) |> 
  arrange(id)

excerpt |> 
  add_row(id = NA) |> 
  select(
    id, income, health, net, 
    malaria_risk_1, malaria_risk_0, ite, malaria_risk
  ) |> 
  gt() |> 
  sub_missing(missing_text = "…") |>
  fmt_number(
    columns = c(starts_with("malaria_risk"), ite),
    decimals = 1
  ) |> 
  fmt_number(columns = c(income, health), decimals = 0) |> 
  
  # Column labels
  cols_label(
    id = "ID",
    income = md("$Z_{1_i}$"),
    health = md("$Z_{2_i}$"),
    net = md("$X_i$"),
    malaria_risk_0 = md("$Y^0_i$"),
    malaria_risk_1 = md("$Y^1_i$"),
    malaria_risk = md("$Y_i$"),
    ite = md("$Y^1_i - Y^0_i$")
  ) |>
  
  # Level 1 spanner labels
  tab_spanner(
    label = "Income", columns = income, 
    level = 1, id = "level1_a"
  ) |> 
  tab_spanner(
    label = "Health", columns = health, 
    level = 1, id = "level1_b"
  ) |> 
  tab_spanner(
    label = "Net use", columns = net, 
    level = 1, id = "level1_c"
  ) |> 
  tab_spanner(
    label = "Potential outcomes",
    columns = c(malaria_risk_1, malaria_risk_0),
    level = 1, id = "level1_d"
  ) |> 
  tab_spanner(
    label = "ICE or \\(\\delta_i\\)", columns = ite, 
    level = 1, id = "level1_e"
  ) |> 
  tab_spanner(
    label = "Outcome", columns = malaria_risk, 
    level = 1, id = "level1_f"
  ) |> 
  
  # Level 2 spanner labels
  tab_spanner(
    label = "Confounders",
    columns = c(income, health),
    level = 2, id = "level2_a"
  ) |> 
  tab_spanner(
    label = "Treatment", columns = net, 
    level = 2, id = "level2_b"
  ) |> 
  tab_spanner(
    label = "Unobservable",
    columns = c(malaria_risk_1, malaria_risk_0, ite), 
    level = 2, id = "level2_c"
  ) |> 
  tab_spanner(
    label = "Realized", columns = malaria_risk, 
    level = 2, id = "level2_d") |> 
  
  # Style stuff
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) |> 
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_body()
  ) |> 
  tab_style(
    style = cell_text(weight = "bold"),
    locations = list(
      cells_column_spanners(spanners = starts_with("level1")),
      cells_column_labels(columns = "id")
    )
  ) |> 
  tab_style(
    style = cell_text(style = "italic"),
    locations = cells_column_spanners(spanners = starts_with("level2"))
  ) |> 
  
  tab_style(
    style = list(
      cell_fill(color = clrs[4], alpha = 0.5)
    ),
    locations = cells_body(rows = net == 1)
  ) |> 
  tab_footnote(
    footnote = "ite = individual causal effect",
    locations = cells_column_spanners(spanners = "level1_e")
  ) |> 
  opt_footnote_marks(marks = "standard") |> 
  opt_horizontal_padding(scale = 3) |> 
  opt_table_font(font = "Jost")
```

Utilicemos estos datos para explorar y calcular tres estimandos diferentes: el ATE, el ATT y el ATU. Para cada estimando, haremos lo siguiente:

1.  Traduciremos de forma sencilla lo que mide el estimando y explicaremos por qué nos interesa.

2.  Calcular el estimando utilizando los efectos causales individuales verdaderos pero no observables (ITE), o $\delta$.

3.  Calcular el estimando utilizando puntuación de propensión basada en ponderación y el cálculo g (g-computation)

## Traducciones simples y valores verdaderos

Este es el aspecto de los datos sintéticos de `nets`: tenemos columnas para cada una de las columnas de la tabla 2, así como algunos indicadores para saber si los ingresos y la salud están por encima del percentil 80:

```{r}
#| label: show-nets-initial
nets |> glimpse()
```

## ATE

```{r}
#| label: calc-ate-true-hidden
#| include: false

nice_number <- scales::label_number(style_negative = "minus", accuracy = 0.1)

true_ate <- mean(nets$ite)
```

El efecto medio del tratamiento (ATE) es lo que siempre he supuesto que la gente quiere encontrar cuando hace inferencia causal. Representa el efecto del uso de mosquiteros en toda la población, incluso si las personas no recibirían normalmente el tratamiento.

Se trata de una estimación muy amplia, por lo que es adecuada para políticas de gran alcance que puedan influir en toda la población, por ejemplo, si un gobierno se plantea distribuir mosquiteros gratuitas o subvencionadas a todos los habitantes del país.

$$
\begin{aligned}
\text{ATE} &= E[\delta_i] & \text{ or} \\
\text{ATE} &= E[Y^1_i - Y^0_i]
\end{aligned}
$$

Conceptualmente, esto es lo mismo que imaginar dos mundos hipotéticos: en el Universo A damos a todo el mundo un mosquitero (aunque no lo necesite), y en el Universo B no damos a nadie un mosquitero. A continuación, calculamos la diferencia de efectos causales individuales entre esos mundos.

Si nos fijamos sólo en las ocho filas de los datos sobre mosquiteros de la tabla, la ATE sería de -13,36:

$$
\frac{(-17.8) + (-9.8) + (-16.9) + (-16) + (-15.6) + (-10.4) + (-8.9) + (-11.5)}{8} = -13.36
$$

Podemos calcularlo con los datos completos tomando la media de la columna ICE. Es `r nice_number(true_ate)`, que es lo que he realizado en los datos:

```{r}
#| label: calc-ate-po
nets |> 
  # I included the alternative versions here just to show that it's 
  # the average of Y1 - average of Y0
  summarize(
    ATE = mean(ite),
    ATE_alt1 = mean(malaria_risk_1) - mean(malaria_risk_0),
    ATE_alt2 = mean(malaria_risk_1 - malaria_risk_0)
  )
```

## ATT

```{r}
#| label: calc-att-true-hidden
#| include: false

true_att <- nets |> 
  filter(net == 1) |> 
  summarize(ATT = mean(ite)) |> 
  pull(ATT)
```

El efecto medio del tratamiento sobre los tratados (ATT) es más limitado que el ATE, pero (¡sorprendentemente!) suele ser más útil y relevante desde el punto de vista político. Representa el efecto del uso de mosquiteros, pero sólo para las personas que usan mosquiteros. Esto resulta extraño, así que aquí van otros ejemplos:

```{r echo =FALSE}
#| label: tbl-ate-vs-att
#| tbl-cap: "Different types of causal effects that can be found as ATEs and ATTs"
#| code-fold: true
#| classes: no-stripe

tribble(
  ~ATE, ~ATT,
  "Efecto de mosquiteros para todos en el país", "Efecto de mosquiteros para personas que los utilizan",
  "Efecto del servicio militar para solicitantes típicos al ejército", "Efecto del servicio militar para soldados típicos",
  "Efecto de un programa de capacitación laboral en todos los residentes de un estado", "Efecto de un programa de capacitación laboral en todos los que lo utilizaron",
  "Efecto de un nuevo medicamento contra el cáncer en todos en el mundo", "Efecto de un nuevo medicamento contra el cáncer en personas con cáncer"
) |> 
  gt() |> 
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  ) |> 
  tab_style(
    style = cell_text(v_align = "top"),
    locations = cells_body()
  ) |> 
  tab_footnote(
    footnote = html("Example via <a href='https://stats.stackexchange.com/a/455012/3025'>this Cross Validated response</a>"),
    locations = cells_body(columns = ATE, rows = 2)
  ) |> 
  opt_footnote_marks(marks = "standard") |> 
  opt_horizontal_padding(scale = 3) |> 
  opt_table_font(font = "Jost")
```

El ATT se siente mucho más útil para propósitos de política. En medicina, se siente mal juzgar la efectividad de un nuevo medicamento basado en el efecto que tendría en cada persona; en evaluación de programas, se siente mal juzgar la efectividad de un programa de capacitación en todos, incluso si nunca lo usarían.

¡Tanto el ATE como el ATT son estimaciones útiles para la política!

Conceptualmente, podemos imaginar dos mundos paralelos nuevamente: en el Universo A le damos a todos los que actualmente usan un mosquitero, y en el Universo B quitamos esos mosquiteros. Luego calculamos la diferencia entre esos mundos. El ATT representa así el efecto de retener los mosquiteros de aquellos que los habrían usado.

¡PERO(!!!), pensar en el ATT se siente extraño, parece que estamos abandonando toda la idea de un grupo de control y solo mirando al grupo tratado.

¿Realmente solo estamos mirando a las personas tratadas?

Veamos la formula del ATT:

$$
\begin{aligned}
\text{ATT} &= E[\delta_i \mid X_i = 1] & \text{or} \\
\text{ATT} &= E[Y^1_i - Y^0_i \mid X_i = 1]
\end{aligned}
$$

Esa parte condicional $[\dots \mid X = 1]$ dice que sólo estamos mirando a las personas tratadas. Y cuando lo calculamos con datos hipotéticos, realmente sólo nos fijamos en las personas tratadas. Así, si sólo nos fijamos en las ocho filas en la tabla, el ATT sería -16,58:

$$
\frac{(-17.8) + (-16.9) + (-16) + (-15.6)}{4} = -16.58
$$

Podemos calcularlo con los datos completos tomando la media de la columna ITE después de filtrar los datos para que sólo nos fijemos en las personas que utilizan un mosquitero. En este ejemplo el ATT es superior al ATE (lo que implica un sesgo de selección).

```{r}
#| label: calc-att-po
nets |> 
  filter(net == 1) |> 
  summarize(ATT = mean(ite))
```

Por eso el ATT puede resultar extraño. Ya no estamos encontrando la diferencia entre las personas tratadas y no tratadas; estamos mirando sólo a las personas tratadas y de alguna manera encontrar un efecto causal.

De hecho, ¡creo que la tabla está haciendo las cosas más confusas al calcular el ATT con datos observados! Cualquier efecto causal es la diferencia entre dos números. Como tenemos datos basados en máquinas del tiempo, estamos encontrando la diferencia entre lo que habría ocurrido en el Universo A y en el Universo B, sólo para las personas tratadas. En la vida real, sin embargo, donde no tenemos una máquina del tiempo, no podemos encontrar esa diferencia. Todavía tenemos que comparar a las personas tratadas con las no tratadas. Simplemente haremos un trabajo estadístico adicional para que las personas no tratadas sean más comparables a las tratadas.

Así pues, *con datos hipotéticos comparamos a las personas tratadas con su yo paralelo e ignoramos a las no tratadas.*

## ATU

```{r}
#| label: calc-atu-true-hidden
#| include: false

true_atu <- nets |> 
  filter(net == 0) |> 
  summarize(ATT = mean(ite)) |> 
  pull(ATT)
```

El efecto medio del tratamiento para los no tratados (ATU) es igual que el ATT, pero a la inversa. Representa el efecto del uso de mosquiteros para las personas que no las utilizan.

Volvamos a los dos mundos paralelos: en el Universo A solo evaluaremos a los que *no* usan un mosquitero actualmente, y en el Universo B entregamos el mosquitero a todos los que *no* lo usan en el universo A. A continuación, calculamos la diferencia entre esos mundos. La ATU representa el efecto del tratamiento en quienes no lo recibieron.

Lo calculamos con datos hipotéticos tomando la media de los efectos causales individuales (ITE) para las personas no tratadas:

$$
\begin{aligned}
\text{ATU} &= E[\delta_i \mid X_i = 0] & \text{or} \\
\text{ATU} &= E[Y^1_i - Y^0_i \mid X_i = 0]
\end{aligned}
$$

Si nos fijamos sólo en la tabla, el ATU sería -10,15:

$$
\frac{(-9.8) + (-10.4) + (-8.9) + (-11.5)}{4} = -10.15
$$

Podemos calcularlo con los datos completos tomando la media de la columna ITE después de filtrar los datos para que sólo nos fijemos en las personas que *no* utilizan red. Es ATU inferior a la ATE (de nuevo, lo que implica un sesgo de selección).

```{r}
#| label: calc-atu-po
nets |> 
  filter(net == 0) |> 
  summarize(ATU = mean(ite))
```

Al igual que con el ATT, con datos hipotéticos comparamos a las personas no tratadas con sus versiones paralelas e ignoramos a las tratadas.

## Sesgo de selección e implicancia sobre el ATE, ATT y ATU

Antes de calcular estos diferentes efectos del tratamiento con los resultados realizados en lugar de los resultados potenciales hipotéticos, echemos un vistazo rápido a la diferencia práctica entre el verdadero ATE, ATT y ATU. ¡Los tres estimadores son útiles para la formulación de políticas!

El ATE es −15, lo que implica que los mosquiteros causan una reducción en promedio de 15 puntos en el riesgo de malaria para cada persona en el país. Esto incluye a personas que viven en elevaciones altas donde los mosquitos no viven, personas que viven cerca de pantanos infestados de mosquitos, personas lo suficientemente ricas como para comprar el láser antimosquitos de Bill Gates, y personas que no pueden permitirse un mosquitero pero les gustaría usar uno.

Sin embargo, si trabajáramos en el Ministerio de Salud y quisiéramos saber si deberíamos implementar un nuevo programa nacional que entregara a todos los peruanos un mosquitero gratis, la reducción general en el riesgo de −15 podría ser no realista.

El ATT es −16.29, que es más grande que el ATE. El efecto del uso del mosquitero es mayor para las personas que ya están usando los mosquiteros. Esto se debe a razones sistemáticas subyacentes o sesgo de selección. Aquellos que usan mosquiteros quieren usarlos porque los necesitan más o pueden acceder a ellos más fácilmente, viven en áreas más propensas a los mosquitos o pueden permitirse comprar sus propios mosquiteros, entre otras cosas. Se conocen a sí mismos y entienden alguna noción de su efecto causal individual personal y buscan mosquiteros. Si les quitáramos el acceso a sus mosquiteros, tendría un efecto negativo mayor.

El ATU es −10.15, que es más pequeño que el ATE. El efecto del uso del mosquitero es menor para las personas que no están usando los mosquiteros. Nuevamente, esto se debe al sesgo de selección. Es probable que aquellos que no usan mosquiteros no lo hagan por razones sistemáticas: viven lejos de los mosquitos, han recibido una vacuna contra la malaria, tienen alguna otra forma de control de mosquitos, entre otras cosas. Debido a que podrían tener poco riesgo de exposición a mosquitos, saben que el uso de mosquiteros no les beneficiará mucho, por lo que no buscan mosquiteros. Así, si les expandiéramos el acceso a los mosquiteros, no se beneficiarían tanto.

Y una nota final sobre el ATE: como vimos antes, incluye tanto al ATT como al ATU. Como es el promedio para todas las personas en toda la población, es la suma de los promedios ponderados de estos dos estimadores:

$$
\text{ATE} = (\pi_\text{Net users} \times \text{ATT}) + (\pi_\text{Net non-users} \times \text{ATU})
$$

Podemos confirmar esto con los datos:

```{r}
#| label: calc-ate-weighted-sum
effect_types <- nets |> 
  group_by(net) |> 
  summarize(
    effect = mean(ite),
    n = n()
  ) |> 
  mutate(
    prop = n / sum(n),
    weighted_effect = effect * prop
  ) |> 
  mutate(estimand = case_match(net, 0 ~ "ATU", 1 ~ "ATT"), .before = 1)
effect_types

effect_types |> 
  summarize(ATE = sum(weighted_effect))
```

### Encontrar estos estimandos con datos no basados en la máquina del tiempo

Hasta ahora hemos calculado el ATE, ATT y ATU con datos basados en una máquina del tiempo. Sin embargo, en la vida real, sólo podemos ver esto:

```{r echo =FALSE}
#| label: Tabla_3
#| tbl-cap: " "
#| code-fold: true
#| classes: no-stripe

excerpt |> 
  add_row(id = NA) |> 
  select(
    id, income, health, net, malaria_risk
  ) |> 
  gt() |> 
  sub_missing(missing_text = "…") |>
  fmt_number(
    columns = malaria_risk,
    decimals = 1
  ) |> 
  fmt_number(columns = c(income, health), decimals = 0) |> 
  
  # Column labels
  cols_label(
    id = "ID",
    income = md("$Z_{1_i}$"),
    health = md("$Z_{2_i}$"),
    net = md("$X_i$"),
    malaria_risk = md("$Y_i$")
  ) |>
  
  # Level 1 spanner labels
  tab_spanner(
    label = "Income", columns = income, 
    level = 1, id = "level1_a_obs"
  ) |> 
  tab_spanner(
    label = "Health", columns = health, 
    level = 1, id = "level1_b_obs"
  ) |> 
  tab_spanner(
    label = "Net use", columns = net, 
    level = 1, id = "level1_c_obs"
  ) |> 
  tab_spanner(
    label = "Outcome", columns = malaria_risk, 
    level = 1, id = "level1_d_obs"
  ) |> 
  
  # Level 2 spanner labels
  tab_spanner(
    label = "Confounders",
    columns = c(income, health),
    level = 2, id = "level2_a_obs"
  ) |> 
  tab_spanner(
    label = "Treatment", columns = net, 
    level = 2, id = "level2_b_obs"
  ) |> 
  tab_spanner(
    label = "Realized", columns = malaria_risk, 
    level = 2, id = "level2_c_obs") |> 
  
  # Style stuff
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) |> 
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_body()
  ) |> 
  tab_style(
    style = cell_text(weight = "bold"),
    locations = list(
      cells_column_spanners(spanners = starts_with("level1")),
      cells_column_labels(columns = "id")
    )
  ) |> 
  tab_style(
    style = cell_text(style = "italic"),
    locations = cells_column_spanners(spanners = starts_with("level2"))
  ) |> 
  
  tab_style(
    style = list(
      cell_fill(color = clrs[4], alpha = 0.5)
    ),
    locations = cells_body(rows = net == 1)
  ) |> 
  opt_horizontal_padding(scale = 3) |> 
  opt_table_font(font = "Jost")
```

$\delta_i$ ha desaparecido; ahora solo tenemos $Y_i$. En lugar de comparar y encontrar las diferencias entre individuos y sus versiones paralelas, necesitamos encontrar las diferencias entre personas tratadas y no tratadas mientras eliminamos el sesgo de selección y la confusión causada por ingresos y salud.

En el ejemplo inicial en la Tabla 1, había solo un confusor (viejo vs. joven), y lo ajustamos estratificando por edad, combinando los promedios ponderados para personas viejas y jóvenes. La estratificación básica como esa es mucho más difícil de hacer aquí. Tanto los ingresos como la salud son variables continuas; no podemos simplemente encontrar promedios ponderados de personas ricas vs. pobres y personas enfermas vs. saludables. Tenemos que hacer algo más sofisticado para crear grupos de comparación comparables, como el emparejamiento o la ponderación.

Es importante destacar que debemos emparejar o ponderar de manera adecuada al estimador que nos importa. El procedimiento de emparejamiento que seguimos para encontrar el ATE no se puede usar para encontrar el ATT; el proceso de ponderación que usamos para el ATU es diferente del que usamos para el ATE.

Noah Greifer tiene dos guías paralelas increíbles para hacer este ajuste, tanto con [ponderación {WeightIt}](https://ngreifer.github.io/WeightIt/articles/estimating-effects.html) así como con [matching {MatchIt}](https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html). En este capítulo, ilustraremos el ATE, ATT y ATU con ayuda de la ponderación considerando puntajes de propensión (Propensity score weighting o Inverse Probability Weighting - IPW), pero los mismos principios se aplican al matching o emparejamiento (Propensity Score Matching); ¡y el código es casi idéntico!)

¡Cubrir los mecanismos exactos de la ponderación de probabilidad inversa va más allá del alcance de este capítulo! Pero descuida, los abordaremos más adelante:

En general, con la ponderación utilizamos confusores para predecir la probabilidad de elegir el tratamiento (la intervención), y luego usamos estos puntajes de propensión para ponderar nuevamente los grupos tratados y no tratados para que se asemejen entre sí, eliminando así cualquier influencia que los confusores tengan en la asignación del tratamiento. Mi modelo mental de la ponderación es que creamos pseudo-poblaciones de personas tratadas y no tratadas que se sienten como lo que sucedería si asignáramos aleatoriamente a todos a condiciones de tratamiento o control, es como crear grupos de tratamiento y control falsos, pero que en realidad se asemeja al mundo ideal donde aleatorizariamos la intervención.

### ATE

Para encontrar el ATE, necesitamos ajustar tanto a los grupos tratados como a los no tratados para que sean comparables. La forma más común de hacer esto es crear pesos de probabilidad inversa, donde todas las personas tratadas obtienen un peso de $\frac{1}{p_i}$ y todas las personas no tratadas obtienen un peso de $\frac{1}{1 - p_i}$ (donde $p_i$ se refiere a los puntajes de propensión de cada persona).

Hablando prácticamente, esto da más peso a las observaciones más inusuales e inesperadas. Por ejemplo, alguien con una alta probabilidad predicha (90%) de elegir usar un mosquitero que luego lo usa no es realmente notable y tendrá un peso bajo ($\frac{1}{0.9}$, o 1.111). Alguien más con una alta probabilidad (90% nuevamente) de elegir un mosquitero que no lo usa tendrá un peso alto ($\frac{1}{1 - 0.9}$, o 10). Esto hace que la persona que debería haber usado un mosquitero sea más comparable a las personas no tratadas correspondientes.

¡La visualización ayuda mucho con esta intuición!

Primero, usaremos regresión logística para calcular las [*probabilidades predichas de usar un mosquitero (esto es el puntaje de propensión)*]{.underline}.

::: callout-warning
## ¿Aún no dominas el lenguaje de R?

No te preocupes. Utilizamos la estadística para demostrar que todo lo que explicamos puede calcularse, y eso significa que en el futuro serás capaz de hacer tus propias estimaciones.

Si el código te resulta complicado por ahora, no te preocupes por entender cada detalle. En los próximos capítulos aprenderás y dominarás todo lo esencial de este lenguaje.
:::

```{r}
# Logistic regression model to predict net usage
model_treatment <- glm(
  net ~ income + health, 
  data = nets, 
  family = binomial(link = "logit")
)

```

Luego, crearemos pesos de probabilidad inversa con esta fórmula, que utiliza el hecho de que recibir mosquitero se codifica como 1 y no recibirlo como 0, para asignar el peso correcto de tratado vs. no tratado:

$$
\frac{\text{Treatment}}{\text{Propensity}} + \frac{1 - \text{Treatment}}{1 - \text{Propensity}}
$$

Nota que si no recibe tratamiento (valor = 0) el primer componente se elimina y qedaría:

$$
Weight = \frac{1}{1 - \text{Propensity}}
$$

Y si recibe el tratamiento (valor = 1) el peso quedaría: $$
Weight = \frac{1}{\text{Propensity}}
$$

```{r}
#| label: calc-wts-net-ate-manual

# Plug original data into the model to generate predicted probabilities
#
# (Here I'm using broom::augment_columns(), but you can also use 
#  marginaleffects::predictions() or even base R's predict())
# 
# Create a new column for the weights
nets_with_weights <- augment_columns(
  model_treatment,
  data = nets,
  type.predict = "response"
) |> 
  rename(propensity = .fitted) |> 
  mutate(wts_ate = (net / propensity) + ((1 - net) / (1 - propensity)))

# See if it worked
ver_ATE <-nets_with_weights |> 
  select(id, income, health, net, malaria_risk, propensity, wts_ate)
```

```{r echo=FALSE}
DT::datatable(ver_ATE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )

```

Alternativamente, podemos utilizar el paquete {WeightIt} para hacer lo mismo:

```{r}
#| label: calc-wts-net-ate

# Get ATE-focused weights for the treatment model
weights_ate <- weightit(
  net ~ income + health, 
  data = nets, 
  method = "glm", 
  estimand = "ATE"
)

# Add the weights as a column in the data
nets_with_weights$wts_ate_automatic <- weights_ate$weights

# They're the same!
ver_ATE <- nets_with_weights |> 
  select(id, wts_ate, wts_ate_automatic) |> 
  head()
```

```{r echo=FALSE}
DT::datatable(ver_ATE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )

```

Veamos de forma gráfica como se ve la distribución de las probabilidades de usar o no mosquiteros (los puntajes de propensión).

```{r echo=FALSE}
#| label: fig-propensity-treated-untreated
#| fig-cap: "Mirrored histogram showing the distribution of propensity scores for treated and untreated people"
#| fig-width: 6
#| fig-height: 3.75
#| code-fold: true

plot_data_weights_ate <- tibble(
  propensity = weights_ate$ps,
  weight = weights_ate$weights,
  treatment = weights_ate$treat
)

ggplot() + 
  geom_histogram(data = filter(plot_data_weights_ate, treatment == 1), 
    bins = 50, aes(x = propensity, fill = "Treated people")) + 
  geom_histogram(data = filter(plot_data_weights_ate, treatment == 0), 
    bins = 50, aes(x = propensity, y = -after_stat(count), fill = "Untreated people")) +
  geom_hline(yintercept = 0, color = "white", linewidth = 0.25) +
  scale_x_continuous(labels = scales::label_percent()) +
  scale_y_continuous(label = abs) +
  scale_fill_manual(values = c(clrs[1], clrs[6]), guide = guide_legend(reverse = TRUE)) +
  labs(x = "Propensity", y = "Count", fill = NULL) +
  theme(
    legend.position = "top",
    legend.key.size = unit(0.65, "lines")
  )
```

En general, las personas que utilizaban mosquiteros tenían una mayor probabilidad de utilizarlas, mientras que las personas que no las utilizaban tenían una menor probabilidad de utilizarlas. Era de esperar.

Pero hay algunas personas que tenían una probabilidad baja de usar redes que *las usaron*, y algunas personas que tenían una probabilidad alta de usar redes que *no las usaron*. Es curioso y extraño. Podría decirse que estas personas son muy parecidas (es decir, con ingresos y salud similares), pero, por la razón que sea, no hicieron lo que el modelo predecía que debían hacer.

```{r , echo=FALSE}
#| label: fig-propensity-weird-highlight
#| fig-cap: 'Mirrored histogram showing "weird" parts of the population: treated people who were unlikely to be treated, and untreated people who were likely to be treated'
#| fig-width: 6
#| fig-height: 3.75
#| code-fold: true

ggplot() + 
  geom_histogram(data = filter(plot_data_weights_ate, treatment == 1), 
    bins = 50, aes(x = propensity, fill = "Treated people")) + 
  geom_histogram(data = filter(plot_data_weights_ate, treatment == 0), 
    bins = 50, aes(x = propensity, y = -after_stat(count), fill = "Untreated people")) +
  annotate(
    geom = "rect", xmin = 0, xmax = 0.55, ymin = -1, ymax = 23,
    fill = alpha(clrs[4], 0.1), color = clrs[4], linewidth = 1
  ) +
  annotate(
    geom = "text", x = 0.01, y = 21.5, 
    label = "Treated people who were\nunlikely to be treated.\nWeird!",
    color = clrs[3], fontface = "bold", hjust = 0, vjust = 1, lineheight = 1
  ) +
  annotate(
    geom = "rect", xmin = 0.58, xmax = 1, ymin = 1, ymax = -27.5,
    fill = alpha(clrs[4], 0.1), color = clrs[4], linewidth = 1
  ) +
  annotate(
    geom = "text", x = 0.99, y = -26, 
    label = "Weird!\nUntreated people who\nwere likely to be treated.",
    color = clrs[3], fontface = "bold", hjust = 1, vjust = 0, lineheight = 1
  ) +
  geom_hline(yintercept = 0, color = "white", linewidth = 0.25) +
  scale_x_continuous(labels = scales::label_percent()) +
  scale_y_continuous(label = abs) +
  scale_fill_manual(values = c(clrs[1], clrs[6]), guide = guide_legend(reverse = TRUE)) +
  labs(x = "Propensity", y = "Count", fill = NULL) +
  theme(
    legend.position = "top",
    legend.key.size = unit(0.65, "lines")
  )
```

Si escalamos la importancia de cada uno según su peso probabilístico inverso, podemos dar más importancia a estas personas "raras" no tratadas-pero-deberían-haber-sido-tratadas y tratadas-pero-no-deberían-haber-sido-tratadas, haciéndolas más equilibradas en comparación con sus homólogos tratados-y-deberían-haber-sido-tratados y no tratados-y-deberían-haber-sido-no-tratados. El histograma más tenue representa las pseudopoblaciones ajustadas y reponderadas de usuarios y no usuarios de la red. Estas dos pseudopoblaciones están ahora libres de los factores de confusión derivados de la salud y los ingresos, y se podría decir que son más comparables, actuando más como grupos aleatorios de tratamiento y control.

```{r , echo=FALSE}
#| label: fig-propensity-weighted-ate
#| fig-cap: "Mirrored histogram showing pseudo-populations of treated and untreated people that have been reweighted to be more comparable and unconfounded"
#| fig-width: 6
#| fig-height: 4.5
#| code-fold: true

ggplot() + 
  geom_histogram(data = filter(plot_data_weights_ate, treatment == 1), 
    bins = 50, aes(x = propensity, weight = weight, fill = "Treated pseudo-population")) + 
  geom_histogram(data = filter(plot_data_weights_ate, treatment == 0), 
    bins = 50, aes(x = propensity, weight = weight, y = -after_stat(count), fill = "Untreated psuedo-population")) +
  geom_histogram(data = filter(plot_data_weights_ate, treatment == 1), 
    bins = 50, aes(x = propensity, fill = "Treated people")) + 
  geom_histogram(data = filter(plot_data_weights_ate, treatment == 0), 
    bins = 50, aes(x = propensity, y = -after_stat(count), fill = "Untreated people")) +
  annotate(
    geom = "text", x = 0.5, y = 60, label = "More weight here", 
    hjust = 0.5, fontface = "bold", color = clrs[3]
  ) +
  annotate(
    geom = "segment", x = 0.48, xend = 0.17, y = 55, yend = 25, color = "white", 
    arrow = arrow(angle = 15, length = unit(0.5, "lines")), linewidth = 2.5
  ) +
  annotate(
    geom = "segment", x = 0.48, xend = 0.17, y = 55, yend = 25, color = clrs[3], 
    arrow = arrow(angle = 15, length = unit(0.5, "lines")), linewidth = 0.5
  ) +
  annotate(
    geom = "segment", x = 0.52, xend = 0.8, y = 55, yend = -20, color = "white", 
    arrow = arrow(angle = 15, length = unit(0.5, "lines")), linewidth = 2.5
  ) +
  annotate(
    geom = "segment", x = 0.52, xend = 0.8, y = 55, yend = -20, color = clrs[3], 
    arrow = arrow(angle = 15, length = unit(0.5, "lines")), linewidth = 0.5
  ) +
  geom_hline(yintercept = 0, color = "white", linewidth = 0.25) +
  scale_x_continuous(labels = scales::label_percent()) +
  scale_y_continuous(label = abs) +
  scale_fill_manual(
    values = c(clrs[1], colorspace::lighten(clrs[1], 0.5), clrs[6], colorspace::lighten(clrs[6], 0.65)), 
    guide = guide_legend(reverse = FALSE, nrow = 2)) +
  labs(x = "Propensity", y = "Count", fill = NULL) +
  theme(
    legend.position = "top",
    legend.key.size = unit(0.65, "lines")
  )
```

Para encontrar el ATE usando estos pesos, podemos ajustar un modelo de regresión para el desenlace. Luego, utilizaremos un enfoque llamado g-computation para encontrar el efecto causal marginal (es decir, el efecto causal de cambiar el mosquitero de "no" a "sí"). La g-computation es un enfoque ingenioso que se siente más como el marco de resultados potenciales original que examinamos anteriormente. Involucra algunos pasos:

1.  Ajustar un modelo de regresión ponderada por el puntaje de propensión que prediga el resultado, como lm(riesgo_malaria \~ mosquitero, weights = w_ate, ...).

2.  Utilizar el modelo para generar un conjunto de predicciones donde fingimos que cada persona usó un mosquitero (es decir, establecemos mosquitero = 1, para todos).

3.  Utilizar el modelo para generar un conjunto de predicciones donde fingimos que cada persona no usó un mosquitero (es decir, establecemos mosquitero = 0, para todos).

4.  Calcular la diferencia entre los dos conjuntos de predicciones para crear una especie de efecto causal individual (ITE) predicho, luego encontrar el promedio de eso. Ese es el ATE.

Eso parece realmente complicado y extenso y parece mucho trabajo de codificación, pero {marignaleffects} hace esto increíblemente fácil. Básicamente, todo lo que tenemos que hacer es usar avg_comparisons(modelo_resultado, variables = list(mosquitero = 0:1)), o incluso más simplemente avg_comparisons(modelo_resultado, variables = "mosquitero"). Esto hará todo el trabajo de establecer el tratamiento de todos en 0 y 1, y encontrar la diferencia. También podemos hacer cosas más sofisticadas con él, como encontrar errores estándar robustos y/o agrupados, o hacer bootstraping para calcular los errores estándar.

```{r}
#| label: calc-net-ate
# Fit an outcome model using the inverse probability weights
model_outcome_ate <- lm(
  malaria_risk ~ net, 
  data = nets_with_weights, 
  weights = wts_ate_automatic
)

# Automatic g-computation with {marginaleffects}! This sets the "net" column to
# each possible value of net (0 and 1) for the whole dataset, then calculates
# the difference between the two sets of predictions
avg_comparisons(model_outcome_ate, variables = "net") 
```

```{r}
#| label: calc-ate-hidden
#| include: false

estimated_ate <- avg_comparisons(model_outcome_ate, variables = "net") |> 
  pull(estimate)

estimated_ate
```

Basándonos en nuestro enfoque de ponderación de probabilidad inversa, el ATE de los datos observacionales (es decir, sin utilizar los resultados potenciales individuales desconocidos) es `-14.7`, ¡que está muy cerca del verdadero ATE de `-15.0`!

### ATT

Esta ATE muestra el efecto del programa de mosquiteros para *todos*, incluso para las personas que no necesitan mosquiteros. Si estamos interesados en hacer de este un programa universal, el ATE es útil. Si lo que nos interesa es saber qué efecto tiene el programa en las personas que lo utilizan, o qué pasaría si lo ampliáramos a las personas que no lo utilizan, tendríamos que encontrar el ATT o el ATU.

Podemos hacer esto con emparejamiento y ponderación, pero *no podemos utilizar el mismo emparejamiento y ponderación que utilizamos para encontrar la ATE.* Al reponderar los datos para estimar la ATT, no debemos hacer nada que altere las ponderaciones del grupo tratado. Dado que estamos interesados en el efecto del programa sólo en las personas tratadas, necesitamos crear un pseudogrupo de control que se parezca al grupo tratado. Hay muchas formas diferentes de hacerlo. Revisar a [Greifer and Stuart](https://doi.org/10.48550/arXiv.2106.10577) para más detalles. Una forma común es dar un peso de 1 a todas las personas tratadas y un peso de $\frac{p_i}{1 - p_i}$ para todas las personas no tratadas.

El proceso es el mismo: ajustar un modelo que prediga si las personas utilizan una red, utilizar esas predicciones para generar ponderaciones y, a continuación, ajustar un modelo de resultados utilizando esas ponderaciones. Con las ponderaciones específicas de ATT, crearemos una pseudopoblación no tratada que es estadísticamente comparable (e infundada) en relación con la población realmente tratada.

```{r }
#| label: calc-wts-net-att
# Get ATT-focused weights for the treatment model
weights_att <- weightit(
  net ~ income + health, 
  data = nets, 
  method = "glm", 
  estimand = "ATT"
)

# Add the weights as a column in the data
nets_with_weights$wts_att <- weights_att$weights

ver_ATT <- nets_with_weights %>% select(id , net , "wts_ate", "wts_att" )

```

```{r, echo=FALSE}

DT::datatable(ver_ATT ,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Nuestro elegante histograma ponderado tiene este aspecto:

```{r, echo=FALSE}
#| label: fig-propensity-weighted-att
#| fig-cap: "Mirrored histogram comparing the distribution of treated people with the reweighted pseudo-population of untreated people; because this is for the ATT, treated people were not reweighted"
#| fig-width: 6
#| fig-height: 3.75
#| code-fold: true

plot_data_weights_att <- tibble(
  propensity = weights_att$ps,
  weight = weights_att$weights,
  treatment = weights_att$treat
)

ggplot() + 
  geom_histogram(data = filter(plot_data_weights_att, treatment == 0), 
    bins = 50, aes(x = propensity, weight = weight, y = -after_stat(count), fill = "Untreated psuedo-population")) +
  geom_histogram(data = filter(plot_data_weights_att, treatment == 1), 
    bins = 50, aes(x = propensity, fill = "Treated people")) + 
  geom_histogram(data = filter(plot_data_weights_att, treatment == 0), 
    bins = 50, alpha = 0.5, 
    aes(x = propensity, y = -after_stat(count), fill = "Untreated people")) +
  geom_hline(yintercept = 0, color = "white", linewidth = 0.25) +
  scale_x_continuous(labels = scales::label_percent()) +
  scale_y_continuous(label = abs) +
  scale_fill_manual(
    values = c(clrs[1], "grey50", colorspace::lighten(clrs[6], 0.65)), 
    guide = guide_legend(reverse = FALSE, nrow = 2)) +
  labs(x = "Propensity", y = "Count", fill = NULL) +
  theme(
    legend.position = "top",
    legend.key.size = unit(0.65, "lines")
  )
```

Las personas tratadas no se tocan: todas tienen un peso de 1 y no nos metemos con ellas. A las personas no tratadas con alta probabilidad de utilizar una red se les da más peso para que se parezcan más a las personas tratadas.

Ajustar el modelo de resultados es lo mismo que hallar el ATE, sólo que utilizaremos las ponderaciones especiales de ATT:

```{r}
#| label: calc-outcome-att
# Fit an outcome model using the ATT weights
model_outcome_att <- lm(
  malaria_risk ~ net, 
  data = nets_with_weights, 
  weights = wts_att
)
```

La principal diferencia es que cuando hacemos el cálculo g, *sólo nos fijamos en las personas tratadas*. Usando solo esta parte de la población, pondremos todos sus valores a 1, luego pondremos todos sus valores a 0, y luego encontraremos la diferencia.

\*\*Esta es la clave para encontrar el efecto del programa sólo en la parte tratada de la población ¿Recuerda cómo cuando teníamos acceso a los efectos causales individuales de cada uno, pudimos encontrar el ATT mirando la media de la columna $\delta$ de todas las personas tratadas? G-computation nos permite esencialmente recrear ese proceso. Así es como funciona:

```{r}
#| label: calc-comparisons-att
# Do g-computation *only* on treated observations
avg_comparisons(
  model_outcome_att, 
  variables = "net", 
  newdata = filter(nets, net == 1)
)
```

```{r}
#| label: calc-att-hidden
#| include: false

estimated_att <- avg_comparisons(
  model_outcome_att, 
  variables = "net", 
  newdata = filter(nets, net == 1)
) |> 
  pull(estimate)

estimated_att
```

El ATT observacional estimada es `-17.6`, que es (1) mayor que la ATE, como se esperaba, y (2) ¡más o menos cercana a la verdadera ATT de `-16.3`!

### ATU

Si nos interesa saber qué pasaría si ampliáramos el programa a personas que no lo utilizan, podemos encontrar la ATU El proceso es el mismo que para la ATT, pero a la inversa. Vamos a crear una pseudo-población de usuarios netos dando un peso de 1 a todas las personas no tratadas y dando un peso de $\frac{1-p_i}{p_i}$ a todas las personas tratadas.

```{r}
#| label: calc-wts-net-atu
# Get ATU-focused weights for the treatment model
weights_atu <- weightit(
  net ~ income + health, 
  data = nets, 
  method = "glm", 
  estimand = "ATC"  # WeightIt calls this ATC instead of ATU
)

# Add the weights as a column in the data
nets_with_weights$wts_atu <- weights_atu$weights
```

Esto es lo que parece un histograma ponderado:

```{r, echo =FALSE}
#| label: fig-propensity-weighted-atu
#| fig-cap: "Mirrored histogram comparing the distribution of untreated people with the reweighted pseudo-population of treated people; because this is for the ATU, untreated people were not reweighted"
#| fig-width: 6
#| fig-height: 3.75
#| code-fold: true

plot_data_weights_atu <- tibble(
  propensity = weights_atu$ps,
  weight = weights_atu$weights,
  treatment = weights_atu$treat
)

ggplot() + 
  geom_histogram(data = filter(plot_data_weights_atu, treatment == 1), 
    bins = 50, aes(x = propensity, weight = weight, fill = "Treated pseudo-population")) + 
  geom_histogram(data = filter(plot_data_weights_atu, treatment == 1), 
    bins = 50, alpha = 0.5, aes(x = propensity, fill = "Treated people")) + 
  geom_histogram(data = filter(plot_data_weights_atu, treatment == 0), 
    bins = 50, aes(x = propensity, y = -after_stat(count), fill = "Untreated people")) +
  geom_hline(yintercept = 0, color = "white", linewidth = 0.25) +
  scale_x_continuous(labels = scales::label_percent()) +
  scale_y_continuous(label = abs) +
  scale_fill_manual(
    values = c("grey50", colorspace::lighten(clrs[1], 0.5), clrs[6], colorspace::lighten(clrs[6], 0.65)), 
    guide = guide_legend(reverse = FALSE, nrow = 2)) +
  labs(x = "Propensity", y = "Count", fill = NULL) +
  theme(
    legend.position = "top",
    legend.key.size = unit(0.65, "lines")
  )
```

Los usuarios de mosquieteros de baja probabilidad reciben mucha más ponderación para que sean comparables al grupo no tratado.

El proceso del modelo de resultados es el mismo que antes: sólo utilizamos las ponderaciones específicas de la ATU Al realizar el cálculo de g, *sólo utilizamos a las personas no tratadas*.

```{r}
#| label: calc-net-atu
# Fit an outcome model using the ATU weights
model_outcome_atu <- lm(
  malaria_risk ~ net, 
  data = nets_with_weights, 
  weights = wts_atu
)

# Do g-computation *only* on untreated observations
avg_comparisons(
  model_outcome_atu, 
  variables = "net", 
  newdata = filter(nets, net == 0)
)
```

```{r}
#| label: calc-atu-hidden
#| include: false

estimated_atu <- avg_comparisons(
  model_outcome_atu, 
  variables = "net", 
  newdata = filter(nets, net == 0)
) |> 
  pull(estimate)

estimated_atu
```

EL ATU observacional estimado es de `-11.7`, que es (1) menor que la ATE, como se esperaba, y (2) ¡más o menos cercana al verdadero ATU de `-13.6`!

### Interpretación

Por último, vamos a mostrar estos estimandos todos juntos, con alguna interpretación básica de lo que significan todos ellos:

```{r}
#| label: tbl-summary
#| tbl-cap: "Summary of the three main estimands"
#| echo: false

interpretation_ate <- glue::glue(
  "Usar un mosquitero reduce el riesgo de malaria en {nice_number(abs(estimated_ate))} puntos, en promedio en toda la población del país"
)
why_ate <- "Útil para entender el efecto de crear una política o programa ampliamente aplicado, como la distribución de mosquiteros subsidiados para todos en el país"

interpretation_att <- glue::glue(
  "Las personas que actualmente usan mosquiteros ven una reducción del riesgo de malaria de {nice_number(abs(estimated_att))} puntos, en promedio"
)
why_att <- "Útil para entender el efecto del uso de mosquiteros en las personas que realmente los utilizan; esto muestra lo que sucedería si retiráramos el programa o quitáramos los mosquiteros a todos"

interpretation_atu <- glue::glue(
  "Las personas que actualmente no usan mosquiteros verían una reducción del riesgo de malaria de {nice_number(abs(estimated_atu))} puntos, en promedio"
)
why_atu <- "Útil para entender el efecto del uso de mosquiteros en las personas que no los utilizan actualmente; esto muestra lo que sucedería si expandiéramos el programa o diéramos mosquiteros a personas que no los tienen"

tribble(
  ~estimand, ~true_value, ~estimated_value, ~interpretation,    ~why,
  "ATE",     true_ate,    estimated_ate,    interpretation_ate, why_ate,
  "ATT",     true_att,    estimated_att,    interpretation_att, why_att,
  "ATU",     true_atu,    estimated_atu,    interpretation_atu, why_atu
) |> 
  gt() |> 
  cols_label(
    estimand = "Estimand",
    true_value = "True value",
    estimated_value = "Estimated value",
    interpretation = "Interpretation",
    why = "Why care?"
  ) |> 
  cols_align(
    align = "left",
    columns = c(estimand, interpretation, why)
  ) |> 
  cols_align(
    align = "center",
    columns = c(true_value, estimated_value)
  ) |> 
  fmt_number(
    columns = c(true_value, estimated_value),
    decimals = 1
  ) |> 
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  ) |> 
  tab_style(
    style = cell_text(v_align = "top"),
    locations = cells_body()
  ) |> 
  tab_source_note(source_note = "Here, the fact that ATT > ATE > ATU implies selection bias; the program works more effectively among those who use it because they know it will help them") |> 
  opt_horizontal_padding(scale = 3) |> 
  opt_table_font(font = "Jost")
```

## ¿Qué otros métodos existen?

¡Es genial saber que estás encontrando claridad al entender los métodos de inferencia causal! De hecho, el Efecto Medio del Tratamiento (ATE) no es el único estimador de interés, y a veces el Efecto Medio del Tratamiento en los Tratados (ATT) puede ser más relevante para las decisiones de política. El ATT se centra específicamente en el efecto del tratamiento para aquellos que realmente lo reciben, brindando información valiosa para intervenciones dirigidas.

Métodos como el de diferencias en diferencias (diff-in-diff) comúnmente utilizados en econometría y ciencias sociales estiman el ATT en lugar del ATE. Este enfoque evalúa el impacto de una intervención únicamente en el grupo tratado, sin depender de un grupo de control. Curiosamente, a pesar de su amplio uso, el diff-in-diff no produce un ATE a nivel de población.

Otras técnicas cuasi experimentales, como la regresión discontinua y las variables instrumentales, ofrecen efectos causales más restringidos. Típicamente, estiman el Efecto Medio del Tratamiento Local (LATE), que se refiere a un segmento más estrecho de la población. Por ejemplo, la regresión discontinua identifica el ATE para individuos cerca de un umbral predefinido que afecta la asignación de tratamiento, mientras que las variables instrumentales estiman el ATE para aquellos que cumplen con la asignación del programa. Estos métodos proporcionan información valiosa sobre efectos causales, pero dentro de subconjuntos específicos de la población.

# Referencias

-   Ross, R.D., Shi, X., Caram, M.E.V. et al. Veridical causal inference using propensity score methods for comparative effectiveness research with medical claims. Health Serv Outcomes Res Method (2020). <https://doi.org/10.1007/s10742-020-00222-8>

-   Elwert, F. (2013). Graphical Causal Models. In S. L. Morgan (Ed.), *Handbook of Causal Analysis for Social Research* (pp. 245--273). Springer.

-   Hernán, M. A., & Robbins, J. M. (2020). *Causal Inference: What If*. CRC Press.

-   Morgan, S. L., & Winship, C. (2007). *Counterfactuals and Causal Inference: Methods and Principles for Social Research*. Cambridge University Press.

-   Pearl, J., Glymour, M., & Jewell, N. P. (2016). *Causal Inference in Statistics: A Primer*. Wiley.

-   Pearl, J., & Mackenzie, D. (2018). *The Book of Why: The New Science of Cause and Effect*. Basic Books.

-   Rohrer, J. M. (2018). Thinking Clearly About Correlations and Causation: Graphical Causal Models for Observational Data. *Advances in Methods and Practices in Psychological Science*, *1*(1), 27--42.

-   Shalizi, C. R. (2019). *Advanced Data Analysis From an Elementary Point of view*. <https://www.stat.cmu.edu/~cshalizi/ADAfaEPoV/ADAfaEPoV.pdf>
